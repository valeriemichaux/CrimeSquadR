---
title: "Datenauswertung"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(tidyverse)
library(psych)
library(ggplot2)
library(fun)
library(colorspace)
library(Hmisc)
library(cowplot)
library(svglite)
library(extrafont)
library(dplyr)
library(ggcorrplot)
library(Hmisc)

```

```{r}
#Dataframes laden und Daten anpassen 
datacleaning <- readr::read_csv("data/datacleaning.csv")

utilities<- readr::read_csv("data/Utilities.csv")

impo<- readr::read_csv2("data/Importances.csv")

importances.incl_SD<- readr::read_csv2("data/Importances_incl_SD.csv")

importances.longer<- readr::read_csv2("data/Importanes_geschlecht_longer.csv")

bind_cols(datacleaning, utilities, impo)-> new

new.short<-new[,c(-1, -9:-10, -22)]

#colnames(new.short)

names(new.short)[8:18]<- c("Konzert","Bahnhof","Einkaufsstraße","Bewegungsverlauf","Gesichtserkennung","Verdächtige Gegenstände", "KI liefert Erklärung", "KI liefert keine Erklärung", "Sofortige Löschung","Löschung nach 3 Monaten", "Dauerhafte Speicherung")
```


```{r}
#Deskriptive Statistik 


mean(new.short$age)
min(new.short$age)
max(new.short$age)
sd(new.short$age)
median(new.short$age)


#new.short%>% 
  #mutate(gender = case_when(
    #gender == "maennlich" ~ 1,
    #gender == "weiblich" ~ 2)) ->new.short

#table(new.short$gender)
#wir haben 41 Männer und 55 Frauen 

#1.Versuch Plot ALter
new.short %>%
  ggplot(aes(x = age, fill = gender)) + geom_histogram() +
  scale_fill_manual(values = c(maennlich = "#a0ced9", weiblich = "#ffc09f"), name = "", labels = c("männlich", "weiblich")) +
  theme_minimal()


#Alter und Geschlecht als Pyramide
new.short %>%
mutate(agegroup = case_when(age >= 55  & age <= 60 ~ '55-60',
                                             age >= 50  & age <= 55 ~ '50-55',
                                             age >= 45  & age <= 50 ~ '45-50',
                            age >= 40  & age <= 45 ~ '40-45',
                            age >= 35  & age <= 40 ~ '35-40',
                            age >= 30  & age <= 35 ~ '30-35',
                            age >= 25  & age <= 30 ~ '25-30',
                            age >= 20  & age <= 25 ~ '20-25',
                            age >= 15  & age <= 20 ~ '15-20')) -> new.short.age.groups
new.short.age.groups %>% 
ggplot(aes(x=as.factor(agegroup),fill=gender)) + 
  geom_bar(data=subset(new.short.age.groups, gender=="weiblich")) + 
  geom_bar(data=subset(new.short.age.groups, gender=="maennlich"),aes(y=..count..*(-1))) + 
  coord_flip() +
  scale_fill_manual(values = c(maennlich = "#a0ced9", weiblich = "#ffc09f"), name = "", labels = c("männlich", "weiblich")) +
  labs(title = "Altersverteilung in der studentischen Stichprobe", y = "Anzahl der Probanden", x = "Alter in Jahren") +
  scale_y_continuous(limits = c(-30, 30), breaks = c(-30, -20, -10, 0, 10, 20, 30), labels=c( "30","20","10","0", "10", "20", "30")) +
  theme_minimal()
```


```{r}
#Importances visualieren 

importances.incl_SD %>%
  ggplot(aes(x = Total, y = fct_reorder(Attribute, Total))) + geom_col(fill = "#adf7b6") + geom_errorbar(aes(xmin = Total - SD, xmax = Total + SD), width = 0.2) +
  scale_x_continuous(limits = c(0, 65), breaks = c(0, 10, 20, 30, 40, 50, 60), expand = c(0.02,0.02)) +
  scale_y_discrete(expand = c(0,0)) +
  labs(x = "Relative Wichtigkeit der Merkmale in % (Fehlerbalke zeigen Standardabweichung)", y = "", title = "Das Merkmal Datenspeicherung ist am wichtigsten hinlänglich\nder Akzeptanz ki-basierter Videoüberwachungssysteme", ) +
  theme_minimal_vgrid(12) -> plot_Importances_General


plot_Importances_General
```

```{r}
#Importances (nach Geschelchtern) visualisieren 

importances.longer %>%
  ggplot(aes(x = score, y = fct_reorder(Attribute, score), fill = gender)) + geom_col(position = "dodge") + 
  geom_errorbar(aes(xmin = score - SD, xmax = score + SD), position= position_dodge(0.9), width = 0.2) +
  scale_x_continuous(limits = c(0, 70), breaks = c(0, 10, 20, 30, 40, 50, 60, 70), expand = c(0.02,0.02)) +
  scale_y_discrete(expand = c(0,0)) +
  scale_fill_manual(values = c(m = "#a0ced9", w = "#ffc09f"), name = "", labels = c("männlich", "weiblich")) +
  labs(x = "Relative Wichtigkeit der Merkmale in % (Fehlerbalke zeigen Standardabweichung)", y = "", title = "Es gibt keine signifikanten Unterschiede bei der Bewertung\nder Merkmale in Bezug auf das Geschlecht ", subtitle = "") +
  theme_minimal_vgrid(12) -> plot_Importances_gender

plot_Importances_gender

```



```{r}
#partworth utilities visualisieren 

pwu<- new.short%>% select("Konzert", "Bahnhof","Einkaufsstraße","Bewegungsverlauf","Gesichtserkennung","Verdächtige Gegenstände", "KI liefert Erklärung", "KI liefert keine Erklärung", "Sofortige Löschung", "Löschung nach 3 Monaten", "Dauerhafte Speicherung")%>%  pivot_longer(cols = everything(), names_to="pwu", values_to="score")


# Dieser Datensatz hat nun 1056 Zeilen wegen 11 (pwus)x 96 Probanden 

#Attribute im Df ergänzen 
pwu%>% 
  mutate(Attribut = case_when(
  pwu == "Bahnhof" ~ "Ort", 
  pwu == "Konzert" ~ "Ort", 
  pwu == "Einkaufsstraße"~ "Ort", 
  pwu == "Bewegungsverlauf" ~ "Datenpartikel",
  pwu == "Gesichtserkennung" ~ "Datenpartikel",
  pwu == "Verdächtige Gegenstände" ~ "Datenpartikel",
  pwu == "KI liefert Erklärung"~ "Erklärbarkeit",
  pwu == "KI liefert keine Erklärung"~ "Erklärbarkeit",
  pwu == "Sofortige Löschung" ~ "Datenspeicherung", 
  pwu == "Löschung nach 3 Monaten"~ "Datenspeicherung",
  pwu == "Dauerhafte Speicherung" ~ "Datenspeicherung"))-> pwu


#colnames(new.short)

#Level ordnen 
pwu$pwu <- factor(
  pwu$pwu,
  levels = c
  ("Konzert",
    "Bahnhof",
    "Einkaufsstraße",
    "Bewegungsverlauf",
    "Gesichtserkennung",
    "Verdächtige Gegenstände",
    "KI liefert Erklärung",
    "KI liefert keine Erklärung",
    "Sofortige Löschung",
    "Löschung nach 3 Monaten",
    "Dauerhafte Speicherung"
  )
)


# Attribute ordnen 
pwu$Attribut<- factor(pwu$Attribut, levels= c ("Datenspeicherung", "Erklärbarkeit", "Datenpartikel", "Ort"))


#Plot differenziert mit Farben
pwu%>%
  ggplot +
  aes(x=pwu, y=score, fill = Attribut)+
   stat_summary(geom = "bar", position = position_dodge()) +
   #stat_summary(fun.data = mean_cl_normal, geom = "errorbar", width=0.5, size=0.4, alpha=0.5) +
    coord_flip()+
  stat_summary(geom="text", aes(label=sprintf("%1.2f%%", ..y..)), size=3, position= position_dodge(width = 0.09)) +
  labs(x="", y="Teilnutzenwerte der Merkmale", fill= "Attribute")+
  scale_fill_manual( values = c ("#adf7b6", "#ffc09f", "#ffee93","#a0ced9"))+
  scale_x_discrete(label=c("Konzert","Bahnhof","Einkaufsstraße","Bewegungsverlauf","Gesichtserkennung","Verdächtige Gegenstände", "KI liefert Erklärung", "KI liefert keine Erklärung", "Sofortige Löschung", "Löschung nach 3 Monaten", "Dauerhafte Speicherung"))+  
  geom_vline(xintercept = 3.52, linetype= "dashed", color= "#D4D4D4")+
   geom_vline(xintercept = 6.52, linetype= "dashed", color= "#D4D4D4")+
   geom_vline(xintercept = 8.53, linetype= "dashed", color= "#D4D4D4")+
theme_minimal_vgrid()



# Schwarz-weiß Plot
pwu%>%
  ggplot+
  aes(x=pwu, y=score)+
   stat_summary(geom = "bar", position = position_dodge(), stat = "identity") +
  stat_summary(geom="text", aes(label=sprintf("%1.2f%%", ..y..)), size=3, position= position_dodge(width = 0.09)) +
   stat_summary(fun.data = mean_cl_normal, geom = "errorbar", width=0.5, size=0.4, alpha=0.5) +
  coord_flip()+
  labs(x="", y="Teilnutzenwerte der Merkmale")+
   scale_x_discrete(label=c("Konzert","Bahnhof","Einkaufsstraße","Bewegungsverlauf","Gesichtserkennung","Verdächtige Gegenstände", "KI liefert Erklärung", "KI liefert keine Erklärung", "Sofortige Löschung", "Löschung nach 3 Monaten", "Dauerhafte Speicherung"))+
theme_minimal_vgrid()


ggsave('data/pwu5.png', width = 20, height = 10, units = "cm", dpi=300)

 

 #Back-Up
 # scale_y_continuous(limits= c(-200,200), breaks=c(-100,-50,0,50,100), labels = c("-100", "-50", "0","50", "100"), expand =     c(0,00000001,0,00000001))
  #ylim(-250,100)+
  #stat_summary(fun.y = mean, geom = "point", size=0.2)+
  #stat_summary(geom="text", aes(label=sprintf("%1.2f%%", ..y..)), size=3, position= position_dodge(width = 0.09)) +

```



```{r}
#Inferenzstatistik 

#T-Test: Welche Geschlechtsunterschiede und Trade-Offs gibt es bei der Akzeptanzbewertung von KI-basierter Videoüberwachung?
#UV: Geschelcht; Gruppen: Männlich & weiblich, AV: Speicherung

#Berechnung t-test

t.test(filter (new.short, gender == "maennlich")$KUT, filter(new.short, gender == "weiblich")$KUT)

t.test(filter (new.short, gender == "maennlich")$Speicherung, filter(new.short, gender == "weiblich")$Speicherung)

#Es gibt keinen signifikanten Unterschied zwischen Männern und Frauen hinsichtlich der Akzeptanz von Datenspeicherung bei KI-basierter Videoüberwachung (t(78.67)= -0.34897, p=.728). 

t.test(filter (new.short, gender == "maennlich")$Datenpartikel, filter(new.short, gender == "weiblich")$Datenpartikel)
#Es gibt keinen signifikanten Unterschied zwischen Männern und Frauen hinsichtlich ihrer Akzeptanz der Art der gesammelten Daten bei KI-basierter Videoüberwachung (t(75.81)= 0.07796, p=.9381).

t.test(filter (new.short, gender == "maennlich")$Ort, filter(new.short, gender == "weiblich")$Ort)
#Es gibt keinen signifikanten Unterschied zwischen Männern und Frauen hinsichtlich ihrer Akzeptanz des Ortes bei KI-basierter Videoüberwachung (t(93.95)= -1.3207, p=.1898).

t.test(filter (new.short, gender == "maennlich")$Erklärbarkeit, filter(new.short, gender == "weiblich")$Erklärbarkeit)
#Es gibt keinen signifikanten Unterschied zwischen Männern und Frauen hinsichtlich der Akzeptanz von Erklärbarkeit bei KI-basierter Videoüberwachung (t(90.97)= 1.4364, p=.1543).


#Korrelationen Alter und Merkmale

cor.test(new.short$age, new.short$Ort,  method="spearman")

cor.test(new.short$age, new.short$Datenpartikel,  method="spearman")

cor.test(new.short$age, new.short$Speicherung,  method="spearman")

cor.test(new.short$age, new.short$Erklärbarkeit,  method="spearman")

#Ergebnis: Es gib keinen signifikanten Zusammenhang zwischen dem Alter und den 4 untersuchten Merkmalen.

#Korrelationen GAAIS und Merkmale

cor.test(new.short$GAAIS, new.short$Ort,  method="spearman")

cor.test(new.short$GAAIS, new.short$Datenpartikel,  method="spearman")

cor.test(new.short$GAAIS, new.short$Speicherung,  method="spearman")

cor.test(new.short$GAAIS, new.short$Erklärbarkeit,  method="spearman")

#Ergebnis: Es gib keinen signifikanten Zusammenhang zwischen dem GAAIS und den 4 untersuchten Merkmalen.

new.short %>%
  select(age, KUT, GAAIS, Ort, Datenpartikel, Speicherung, Erklärbarkeit) -> cor.data

##### 1. Versuch Matrix mit cor() Funktion -> Matrix der Korrelationswerte, nicht p-Werte
cor(cor.data, method = "spearman")

##### 2. Versuch Matrix mit rstatix Paket -> Tabelle mit p-Werten unüberischtlich
library(rstatix)

cor_mat(cor.data, method = "spearman")
cor_pmat(cor.data, method = "spearman")

##### 3. Versuch Matrix mit Funktion aus dem Web -> optisch am schönsten
correlation_matrix(cor.data, type = "spearman", digits = 3, decimal.mark = ".", use = "all", show_significance = TRUE, replace_diagonal = TRUE, replacement = "")





```
```{r}
# Code zur Erstellung der Funktion für Korrelationsmatrix
#' correlation_matrix
#' Creates a publication-ready / formatted correlation matrix, using `Hmisc::rcorr` in the backend.
#'
#' @param df dataframe; containing numeric and/or logical columns to calculate correlations for
#' @param type character; specifies the type of correlations to compute; gets passed to `Hmisc::rcorr`; options are `"pearson"` or `"spearman"`; defaults to `"pearson"`
#' @param digits integer/double; number of decimals to show in the correlation matrix; gets passed to `formatC`; defaults to `3`
#' @param decimal.mark character; which decimal.mark to use; gets passed to `formatC`; defaults to `.`
#' @param use character; which part of the correlation matrix to display; options are `"all"`, `"upper"`, `"lower"`; defaults to `"all"`
#' @param show_significance boolean; whether to add `*` to represent the significance levels for the correlations; defaults to `TRUE`
#' @param replace_diagonal boolean; whether to replace the correlations on the diagonal; defaults to `FALSE`
#' @param replacement character; what to replace the diagonal and/or upper/lower triangles with; defaults to `""` (empty string)
#'
#' @return a correlation matrix
#' @export
#'
#' @examples
#' `correlation_matrix(iris)`
#' `correlation_matrix(mtcars)`
correlation_matrix <- function(df, 
                               type = "pearson",
                               digits = 3, 
                               decimal.mark = ".",
                               use = "all", 
                               show_significance = TRUE, 
                               replace_diagonal = FALSE, 
                               replacement = ""){
  
  # check arguments
  stopifnot({
    is.numeric(digits)
    digits >= 0
    use %in% c("all", "upper", "lower")
    is.logical(replace_diagonal)
    is.logical(show_significance)
    is.character(replacement)
  })
  # we need the Hmisc package for this
  require(Hmisc)
  
  # retain only numeric and boolean columns
  isNumericOrBoolean = vapply(df, function(x) is.numeric(x) | is.logical(x), logical(1))
  if (sum(!isNumericOrBoolean) > 0) {
    cat('Dropping non-numeric/-boolean column(s):', paste(names(isNumericOrBoolean)[!isNumericOrBoolean], collapse = ', '), '\n\n')
  }
  df = df[isNumericOrBoolean]
  
  # transform input data frame to matrix
  x <- as.matrix(df)
  
  # run correlation analysis using Hmisc package
  correlation_matrix <- Hmisc::rcorr(x, type = type)
  R <- correlation_matrix$r # Matrix of correlation coeficients
  p <- correlation_matrix$P # Matrix of p-value 
  
  # transform correlations to specific character format
  Rformatted = formatC(R, format = 'f', digits = digits, decimal.mark = decimal.mark)
  
  # if there are any negative numbers, we want to put a space before the positives to align all
  if (sum(!is.na(R) & R < 0) > 0) {
    Rformatted = ifelse(!is.na(R) & R > 0, paste0(" ", Rformatted), Rformatted)
  }

  # add significance levels if desired
  if (show_significance) {
    # define notions for significance levels; spacing is important.
    stars <- ifelse(is.na(p), "", ifelse(p < .001, "***", ifelse(p < .01, "**", ifelse(p < .05, "*", ""))))
    Rformatted = paste0(Rformatted, stars)
  }
  
  # make all character strings equally long
  max_length = max(nchar(Rformatted))
  Rformatted = vapply(Rformatted, function(x) {
    current_length = nchar(x)
    difference = max_length - current_length
    return(paste0(x, paste(rep(" ", difference), collapse = ''), sep = ''))
  }, FUN.VALUE = character(1))
  
  # build a new matrix that includes the formatted correlations and their significance stars
  Rnew <- matrix(Rformatted, ncol = ncol(x))
  rownames(Rnew) <- colnames(Rnew) <- colnames(x)
  
  # replace undesired values
  if (use == 'upper') {
    Rnew[lower.tri(Rnew, diag = replace_diagonal)] <- replacement
  } else if (use == 'lower') {
    Rnew[upper.tri(Rnew, diag = replace_diagonal)] <- replacement
  } else if (replace_diagonal) {
    diag(Rnew) <- replacement
  }
  
  return(Rnew)
}
```

